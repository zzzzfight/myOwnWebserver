**比较重要的几个类：**
* `Acctepor`类
	* 主线程处理的事件的内容（`channel`中注册的回调函数来源） 

* `EPollPoller`类
	* `channels_`:存储事件处理对象
	* `https_`:存储事件处理对象的具体内容，应用层上
	`httpdata_`将回调函数传给`channel_`,`channel`对产生不同的`EPOLL`事件进行响应

* `Timer`类
	* 小根堆计时器，负责超时释放资源
* 线程类
	* 线程池的安全启动，用到了互斥锁，条件变量等

</br>

**主体逻辑:**
1. 主线程(`Acceptor`向`channel`注册回调函数)负责监听外部的事件请求，并建立`TCP/IP`连接。
2. 从`EventLoopThreadPool`中取出（负载均衡（可以这么说吧）采用轮询的方式）`subloop`;
3. 建立事件的实际处理对象{`httpdata`对象和`channel`对象（并注册回调函数）}将对该事件的处理权转交()给`subloop`（对应`loop->queueInLoop(std::bind(&HttpData::newEvent, newHttpConn));`）
4. `EPollPoller`类负责执行epoll事件的处理，以及所有发生的连接的实际处理对象的管理（持有shared_ptr<HttpData>和shared_ptr<Channel>，防止执行回调函数时发生的意外析构）
5. `EventLoop`类 通过Channel对发生的事件进行处理（通过回调函数）删除计时器超时的结点。
6. 对`HttpData`及`Channel`对象（下通称对象）的资源释放发生在两种情况：
	* 超时,计时器`pop() timenode` 析构中执行`handleClose()`
	* `http`解析产生`error`，执行`handleClose()`
	无论是哪种都有一个前提，保证执行回调函数执行期间，对象不会提前析构，那么当在执行回调函数的时候，需要将对对象析构权从计时器释放（`seperaterTimer()`）,`handleConn()`会负责重新在计时器中注册或者直接调用`handleClose()`


</br>

**其他问题**
* 长连接分包如何处理？
完整报文直接处理，不完整报文先读，然后处理

* 如果一个`HTTP`协议内容不完整，然后再次`tcp`传入后在分析，是否保证程序正确性？
	* 逻辑可能存在缺陷，因为解析协议默认认为每次传入的报文是正确的（完整正确，不完整正确）
	* 协议解析思路按行，每次先保证行完整，然后堆行内容解析，如果行不完整，认为报文内容不完整，`inBuffer`状态不改，跳出等待下一次`EPOLLIN`事件,然后将`inBuffer`补完，然后再次解析。
	* 有所修改实际，应该是没问题的，行不完整会在直接跳至read

* 网络库的内容大致没问题，`http`功能可能不完善，`post`的解析，或者视频的传输，这些还没解决。

* `http`类 与 `channel`类 的相互引用 可以将`http`对`channel`的引用改为`weak_ptr`,`channel`对`http`的引用改为`shared_ptr`，
然后回调函数将传入的`this` 改为`enable_shared_from()`
这样就不用额外在`EPollPoller`类中用一个 `hashmap`存储`shared_ptr<HttpData>` ,因为`http`的析构只会发生在`channel`的析构时。

* `HttpData`中`buffer`的设计
	* 本来想仿照`muduo`的`Buffer.cc`，设计`HttpData`中输入输出缓存的类（本来是`string`）,但是大致看了下`muduo`地思路，核心还是使用`vector`存储字符，超出长度对其进行扩容。和string的底层差不多，超出`capacity()`,两倍扩容。考虑用环形数组来降低可能发生的字符数据移动，但是这样的话在数组长度不够而进行必要的扩容时，会很麻烦，因为扩容从尾端开始，但是尾端的数据不是数据末尾（好像也不难实现，延迟修改环数组的取模值，修改时记录`olderreadpos`，在下一次`readpos==olderreadpos`时调整环数组的取模值并修改位置，写则是在数据满时将`write`置于尾端+1并修改环数组模值，不过似乎要维护两个数组模，还是很复杂）
	* 实际尝试自写缓存池，然而需要封装重写各种IO函数，如果有时间再尝试

* 大文件传输
	* 按照muduo的思想是分批传输，如果有时间再尝试
* webbench 压测
	* 已测，效率可观，做了一些小优化，比如函数传参，改为引用，总体上没有什么效率的提升，可能是C++ 编译器本来就进行过NRV优化，所以引用传参，和值传参再返回基本上没有区别了。（NRV优化会将返回的目标对象，直接作为函数引用参数，这样会少一个临时对象，从而减少拷贝构造，赋值，以及临时对象的资源回收，引用传参的本意也是这样，所以这样优化并没有导致实际效率的显著提升）

* 数据库连接池（还有时间的话）
	* 如果尝试写个注册界面，就会涉及到mysql，需要写一个连接池，具体操作就是调用mysql提供的api，之前在TinyWebServer已经尝试过，总体理论不难，如果有时间再尝试

</br>

* 写给自己的话
	* 有时间在改进吧，暂时这个项目就告一段落，有很多不满意地方，有很多没有实现的地方，可能也存在一些bug？（http的解析）,比如一个异步日志，比如`http`协议中其他请求的设计，比如把它实现未一个多功能的协议解析服务器？但是接下来的时间想交给刷题和内功。
	* 最后秋招临近，期待自己能够拿到理想的offer。

</br>

* 最后的最后
	* （如果有有缘人）有交流的兴趣，可以邮件我(3161349290@qq.com)
	* 借鉴了很多WebServer/TinyWebServer和muduo库的内容，开始就是从WebServer作为起点，很感谢该作者。
	* 也融入了自己的理解。
	* **如果该项目对你有所帮助，请star一下吧！**